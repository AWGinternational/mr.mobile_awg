// POS Dashboard API - Real-time dashboard data for POS system (Multi-tenant)import { NextRequest, NextResponse } from 'next/server'import { withShopContext } from '@/lib/shop-context'import { z } from 'zod'const DashboardQuerySchema = z.object({  timeframe: z.enum(['today', 'week', 'month']).default('today'),})// GET /api/pos/dashboard - Get real-time POS dashboard dataexport const GET = withShopContext(async (context, request: NextRequest) => {  try {    const { searchParams } = new URL(request.url)    const queryData = {      timeframe: searchParams.get('timeframe') || 'today',    }    const validatedQuery = DashboardQuerySchema.parse(queryData)    // Set date range based on timeframe    let startDate: Date    const endDate = new Date()    switch (validatedQuery.timeframe) {      case 'today':        startDate = new Date()        startDate.setHours(0, 0, 0, 0)        break      case 'week':        startDate = new Date()        startDate.setDate(startDate.getDate() - 7)        break      case 'month':        startDate = new Date()        startDate.setMonth(startDate.getMonth() - 1)        break      default:        startDate = new Date()        startDate.setHours(0, 0, 0, 0)    }    // Parallel data fetching for performance    const [      sales,      totalProducts,      lowStockProducts,      pendingSales,      topSellingProducts,      recentCustomers,      inventoryValue    ] = await Promise.all([      // Sales data      context.shopDB.sale.findMany({        where: {          saleDate: { gte: startDate, lte: endDate },          status: 'COMPLETED'        },        include: {          customer: { select: { name: true, phone: true } },          items: {            include: {              product: { select: { name: true, costPrice: true } }            }          }        },        orderBy: { saleDate: 'desc' }      }),      // Total active products      context.shopDB.product.count({        where: { status: 'ACTIVE' }      }),      // Low stock products      context.shopDB.product.findMany({        where: {          status: 'ACTIVE',          inventoryItems: {            some: {              status: 'IN_STOCK'            }          }        },        include: {          inventoryItems: {            where: { status: 'IN_STOCK' }          },          category: { select: { name: true } },          brand: { select: { name: true } }        }      }),      // Pending/incomplete sales      context.shopDB.sale.count({        where: {          createdAt: { gte: startDate },          status: 'PENDING'        }      }),      // Top selling products (last 30 days)      context.shopDB.saleItem.groupBy({        by: ['productId'],        where: {          sale: {            saleDate: {              gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)            },            status: 'COMPLETED'          }        },        _sum: { quantity: true },        _count: { id: true },        orderBy: { _sum: { quantity: 'desc' } },        take: 10      }),      // Recent customers      context.shopDB.customer.findMany({        orderBy: { createdAt: 'desc' },        take: 10,        include: {          _count: { select: { sales: true } },          sales: {            select: { totalAmount: true },            orderBy: { saleDate: 'desc' },            take: 1          }        }      }),      // Total inventory value      context.shopDB.inventoryItem.aggregate({        where: { status: 'IN_STOCK' },        _sum: { costPrice: true },        _count: { id: true }      })    ])    // Process low stock products    const lowStockItems = lowStockProducts      .map((product: any) => {        const stockCount = product.inventoryItems.length        return {          id: product.id,          name: product.name,          sku: product.sku,          category: product.category.name,          brand: product.brand.name,          currentStock: stockCount,          lowStockThreshold: product.lowStockThreshold,          reorderPoint: product.reorderPoint,          isLowStock: stockCount <= product.lowStockThreshold,          isReorderNeeded: stockCount <= product.reorderPoint        }      })      .filter((product: any) => product.isLowStock)      .sort((a: any, b: any) => a.currentStock - b.currentStock)    // Get product details for top selling items    const topSellingProductDetails = await Promise.all(      topSellingProducts.map(async (item: any) => {        const product = await context.shopDB.product.findUnique({          where: { id: item.productId },          include: {            category: { select: { name: true } },            brand: { select: { name: true } }          }        })        return {          product,          quantitySold: item._sum.quantity || 0,          salesCount: item._count.id        }      })    )    // Calculate metrics    const totalRevenue = sales.reduce((sum: number, sale: any) => sum + Number(sale.totalAmount), 0)    const totalProfit = sales.reduce((sum: number, sale: any) => {      const profit = sale.items.reduce((itemSum: number, item: any) => {        const costPrice = Number(item.product.costPrice) * item.quantity        const sellingPrice = Number(item.totalPrice)        return itemSum + (sellingPrice - costPrice)      }, 0)      return sum + profit    }, 0)    const totalTransactions = sales.length    const averageOrderValue = totalTransactions > 0 ? totalRevenue / totalTransactions : 0    // Payment method distribution    const paymentMethods = sales.reduce((acc: Record<string, { count: number, amount: number }>, sale: any) => {      const method = sale.paymentMethod      if (!acc[method]) {        acc[method] = { count: 0, amount: 0 }      }      acc[method].count++      acc[method].amount += Number(sale.totalAmount)      return acc    }, {})    // Hourly sales pattern (for today only)    const hourlySales = validatedQuery.timeframe === 'today'       ? sales.reduce((acc: Record<number, { count: number, revenue: number }>, sale: any) => {          const hour = sale.saleDate.getHours()          if (!acc[hour]) {            acc[hour] = { count: 0, revenue: 0 }          }          acc[hour].count++          acc[hour].revenue += Number(sale.totalAmount)          return acc        }, {})      : {}    // Recent activity    const recentActivity = sales.slice(0, 20).map((sale: any) => ({      id: sale.id,      type: 'sale',      description: `Sale to ${sale.customer?.name || 'Walk-in Customer'}`,      amount: Number(sale.totalAmount),      timestamp: sale.saleDate,      details: {        invoiceNumber: sale.invoiceNumber,        itemCount: sale.items.length,        paymentMethod: sale.paymentMethod      }    }))    const dashboardData = {      summary: {        timeframe: validatedQuery.timeframe,        totalRevenue,        totalProfit,        profitMargin: totalRevenue > 0 ? (totalProfit / totalRevenue) * 100 : 0,        totalTransactions,        averageOrderValue,        totalProducts,        lowStockCount: lowStockItems.length,        pendingSales,        inventoryValue: Number(inventoryValue._sum.costPrice || 0),        inventoryItems: inventoryValue._count.id      },      sales: {        recent: sales.slice(0, 10).map((sale: any) => ({          id: sale.id,          invoiceNumber: sale.invoiceNumber,          customer: sale.customer?.name || 'Walk-in Customer',          totalAmount: Number(sale.totalAmount),          itemCount: sale.items.length,          paymentMethod: sale.paymentMethod,          saleDate: sale.saleDate        })),        paymentMethods: Object.entries(paymentMethods).map(([method, data]: [string, any]) => ({          method,          count: data.count,          amount: data.amount,          percentage: totalRevenue > 0 ? (data.amount / totalRevenue) * 100 : 0        })),        hourlySales: Object.entries(hourlySales).map(([hour, data]: [string, any]) => ({          hour: parseInt(hour),          count: data.count,          revenue: data.revenue        })).sort((a, b) => a.hour - b.hour)      },      inventory: {        lowStockItems: lowStockItems.slice(0, 20),        topSelling: topSellingProductDetails.map((item: any) => ({          id: item.product?.id,          name: item.product?.name,          sku: item.product?.sku,          category: item.product?.category.name,          brand: item.product?.brand.name,          quantitySold: item.quantitySold,          salesCount: item.salesCount,          sellingPrice: Number(item.product?.sellingPrice || 0)        }))      },      customers: {        recent: recentCustomers.map((customer: any) => ({          id: customer.id,          name: customer.name,          phone: customer.phone,          totalPurchases: customer._count.sales,          lastPurchaseAmount: customer.sales[0] ? Number(customer.sales[0].totalAmount) : 0,          createdAt: customer.createdAt        })),        totalCount: recentCustomers.length      },      activity: recentActivity    }    return NextResponse.json({      success: true,      dashboard: dashboardData,      timestamp: new Date().toISOString()    })  } catch (error) {    console.error('Dashboard data error:', error)        if (error instanceof z.ZodError) {      return NextResponse.json(        { error: 'Invalid query parameters', details: error.issues },        { status: 400 }      )    }    return NextResponse.json(      { error: 'Failed to fetch dashboard data' },      { status: 500 }    )  }})